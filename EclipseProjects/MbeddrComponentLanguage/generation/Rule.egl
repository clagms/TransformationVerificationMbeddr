[%
var nodeIndex = 0;

var matchModelIndex = 0;
var applyModelIndex = 0;
var pairedWithNodeIndex = 0;

var matchClassNodeMap : new Map;
var matchContainsClassNodeMap : new Map;

var applyClassNodeMap : new Map;
var applyContainsClassNodeMap : new Map;


var matchAssociationNodeMap : new Map;

var applyAssociationNodeMap : new Map;

var backwardAssociationNodeMap: new Map;


%]
from core.himesis import Himesis
import cPickle as pickle
from uuid import UUID

class H[%=rule.description%](Himesis):
    def __init__(self):
        """
        Creates the himesis graph representing the DSLTrans rule [%=rule.description%].
        """
        # Flag this instance as compiled now
        self.is_compiled = True
        
        # TODO: compute total number of vertices
        super(H[%=rule.description%], self).__init__(name='H[%=rule.description%]', num_nodes=[%=0%], edges=[])
        
        
        # Set the graph attributes
        # TODO Levi, need some help here
        self["mm__"] = pickle.loads("""I have no idea what goes here""")
        
        self["name"] = """[%=rule.description%]"""
        self["GUID__"] = UUID('[%=rule.description%]')
        
        # match model. We only support one match model
        [%
        matchModelIndex = nodeIndex;
    	%]
        self.vs[[%=nodeIndex%]]["mm__"] = """MatchModel"""
        self.vs[[%=nodeIndex%]]["GUID__"] = UUID('[%=rule.description%]matchmodel[%=nodeIndex%]')
    	[%
		nodeIndex = nodeIndex + 1;
        %]
        
        # apply model node
        [%
    	applyModelIndex = nodeIndex;
    	%]
        self.vs[[%=nodeIndex%]]["mm__"] = """ApplyModel"""
        self.vs[[%=nodeIndex%]]["GUID__"] = UUID('[%=rule.description%]applymodel[%=nodeIndex%]')
    	[%
    	nodeIndex = nodeIndex + 1;
        %]
        
        # paired with relation between match and apply models
        [%
    	pairedWithNodeIndex = nodeIndex;
    	%]
        self.vs[[%=nodeIndex%]]["mm__"] = """paired_with"""
        self.vs[[%=nodeIndex%]]["GUID__"] = UUID('[%=rule.description%]pairedwith[%=nodeIndex%]')
        [%
    	nodeIndex = nodeIndex + 1;
        %]
        
        [%
		for(class in rule.match.first.class){
			matchClassNodeMap.put(class, nodeIndex);
			%]
    	# match class [%=class.className%]([%=class.id%]) node
    	self.vs[[%=nodeIndex%]]["name"] = """[%=class.id%]"""
        self.vs[[%=nodeIndex%]]["classtype"] = """[%=class.className%]"""
        self.vs[[%=nodeIndex%]]["mm__"] = """[%=class.className%]"""
        self.vs[[%=nodeIndex%]]["cardinality"] = """[%= getClassCardinality(class) %]"""
        self.vs[[%=nodeIndex%]]["GUID__"] = UUID('[%=class.id%]')
    		[%
    		nodeIndex = nodeIndex + 1;
    		%]
    	# match_contains node for class [%=class.className%]([%=class.id%])
        	[%
    		matchContainsClassNodeMap.put(class, nodeIndex);
    		%]
        self.vs[[%=nodeIndex%]]["mm__"] = """match_contains"""
        self.vs[[%=nodeIndex%]]["GUID__"] = UUID('[%=class.id%]matchcontains[%=nodeIndex%]')
        	[%
    		nodeIndex = nodeIndex + 1;
    	}
        %]
        
        
        [%
		for(class in rule.apply.class){
			applyClassNodeMap.put(class, nodeIndex);
			%]
    	# apply class [%=class.className%]([%=class.id%]) node
    	self.vs[[%=nodeIndex%]]["name"] = """[%=class.id%]"""
        self.vs[[%=nodeIndex%]]["classtype"] = """[%=class.className%]"""
        self.vs[[%=nodeIndex%]]["mm__"] = """[%=class.className%]"""
        self.vs[[%=nodeIndex%]]["cardinality"] = """1"""
        self.vs[[%=nodeIndex%]]["GUID__"] = UUID('[%=class.id%]')
    		[%
    		nodeIndex = nodeIndex + 1;
    		%]
    	# apply_contains node for class [%=class.className%]([%=class.id%])
        	[%
    		applyContainsClassNodeMap.put(class, nodeIndex);
    		%]
        self.vs[[%=nodeIndex%]]["mm__"] = """apply_contains"""
        self.vs[[%=nodeIndex%]]["GUID__"] = UUID('[%=class.id%]applycontains[%=nodeIndex%]')
        	[%
    		nodeIndex = nodeIndex + 1;
    	}
        %]
        
        
        [%
		for(association in rule.match.first.association){
			matchAssociationNodeMap.put(association, nodeIndex);
			%]
    	# match association [%=association.source.className%]--[%=association.associationName%]-->[%=association.target.className%] node
    	self.vs[[%=nodeIndex%]]["associationType"] = """[%=association.associationName%]"""
        self.vs[[%=nodeIndex%]]["mm__"] = """directLink_S"""
        self.vs[[%=nodeIndex%]]["GUID__"] = UUID('[%=association.source.id + ("assoc" + nodeIndex) + association.target.id %]')
    		[%
    		nodeIndex = nodeIndex + 1;
    	}
        %]
        
        [%
		for(association in rule.apply.association){
			applyAssociationNodeMap.put(association, nodeIndex);
			%]
    	# apply association [%=association.source.className%]--[%=association.associationName%]-->[%=association.target.className%] node
    	self.vs[[%=nodeIndex%]]["associationType"] = """[%=association.associationName%]"""
        self.vs[[%=nodeIndex%]]["mm__"] = """directLink_T"""
        self.vs[[%=nodeIndex%]]["GUID__"] = UUID('[%=association.source.id + ("assoc" + nodeIndex) + association.target.id %]')
    		[%
    		nodeIndex = nodeIndex + 1;
    	}
        %]
        
        [%
		for(backwardAssociation in rule.backwards){
			backwardAssociationNodeMap.put(backwardAssociation, nodeIndex);
			%]
    	# backward association [%=backwardAssociation.sourceClass.className%]---->[%=backwardAssociation.targetClass.className%] node
    	self.vs[[%=nodeIndex%]]["type"] = """ruleDef"""
        self.vs[[%=nodeIndex%]]["mm__"] = """backward_link"""
        self.vs[[%=nodeIndex%]]["GUID__"] = UUID('[%=backwardAssociation.sourceClass.id + ("blink" + nodeIndex) + backwardAssociation.targetClass.id %]')
    		[%
    		nodeIndex = nodeIndex + 1;
    	}
        %]
        
        # Add the edges
        self.add_edges([
        	([%=matchModelIndex%],[%=pairedWithNodeIndex%]), # matchmodel -> pairedwith
        	([%=pairedWithNodeIndex%],[%=applyModelIndex%]), # pairedwith -> applyModel
        	[%
    		for(class in rule.match.first.class){
    		%]
    		([%= matchModelIndex%],[%= matchContainsClassNodeMap.get(class)%]), # matchmodel -> match_contains
    		([%= matchContainsClassNodeMap.get(class)%],[%= matchClassNodeMap.get(class)%]), # match_contains -> match_class [%=class.className%]([%=class.id%])
    		[%
    		}
    		
    		for(class in rule.apply.class){
    		%]
    		([%= applyModelIndex%],[%= applyContainsClassNodeMap.get(class)%]), # applymodel -> apply_contains
    		([%= applyContainsClassNodeMap.get(class)%],[%= applyClassNodeMap.get(class)%]), # apply_contains -> apply_class [%=class.className%]([%=class.id%])
    		[%
    		}
    		
    		for(association in rule.match.first.association){
    		%]
    		([%= matchClassNodeMap.get(association.source)%],[%= matchAssociationNodeMap.get(association)%]), # match_class [%=association.source.className%]([%=association.source.id%]) -> association [%=association.associationName%]
    		([%= matchAssociationNodeMap.get(association) %],[%= matchClassNodeMap.get(association.target)%]), # association [%=association.associationName%]  -> match_class [%=association.target.className%]([%=association.target.id%])
    		[%
    		}
    		
    		for(association in rule.apply.association){
    		%]
    		([%= applyClassNodeMap.get(association.source)%],[%= applyAssociationNodeMap.get(association)%]), # apply_class [%=association.source.className%]([%=association.source.id%]) -> association [%=association.associationName%]
    		([%= applyAssociationNodeMap.get(association) %],[%= applyClassNodeMap.get(association.target)%]), # association [%=association.associationName%]  -> apply_class [%=association.target.className%]([%=association.target.id%])
    		[%
    		}
    		
    		for(backwardAssociation in rule.backwards){
    		%]
    		([%= applyClassNodeMap.get(backwardAssociation.targetClass)%],[%= backwardAssociationNodeMap.get(backwardAssociation)%]), # apply_class [%=backwardAssociation.targetClass.className%]([%=backwardAssociation.targetClass.id%]) -> backward_association
    		([%= backwardAssociationNodeMap.get(backwardAssociation) %],[%= matchClassNodeMap.get(backwardAssociation.sourceClass)%]), #  backward_association -> apply_class [%=backwardAssociation.sourceClass.className%]([%=backwardAssociation.sourceClass.id%])
    		[%
    		}
        	%]
        ])
        
[%
operation getClassCardinality(class){
	if (class.isKindOf(AnyMatchClass)){
		return "+";
	} else {
		throw "Only Any Match Class is supported!";
	}
}
%]